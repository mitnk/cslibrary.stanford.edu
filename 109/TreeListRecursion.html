<!doctype html public "-//w3c//dtd html 4.0 transitional//en"><html><head>   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">   <meta name="Content-Type" content="text/html; charset=iso-8859-1">   <meta name="KeyWords" content="recursion, linked list, binary tree, example, code, java, c, c++">   <meta name="GENERATOR" content="Mozilla/4.77 (Macintosh; U; PPC) [Netscape]">   <meta name="Author" content="Nick Parlante">   <meta name="Description" content="Presents the best recursive pointer problem it has ever been my pleasure to see.This an advanced problem that uses pointers, binary trees, linked lists, and some significant recursion. Solutions are provided in Java and C.">   <title>Tree List Recursion Problem</title></head><body text="#000000" bgcolor="#FFFFFF" link="#0000FF" vlink="#551A8B" alink="#0000FF"><!---I want to use CSS2 codes to keep the images from page breaking awayfrom the the prose. Will use somthing like..style="page-break-before: avoid" or always--><center><h1>The Great Tree-List Recursion Problem</h1></center><center><font size=-1>by Nick Parlante</font><br><font size=-1>nick.parlante@cs.stanford.edu</font><br><font size=-1>Copyright 2000, Nick Parlante</font></center><p>This article presents one of the neatest recursive pointer problemsever devised. This an advanced problem that uses pointers, binary trees,linked lists, and some significant recursion. This article includes theproblem statement, a few explanatory diagrams, and sample solution codein Java and C. Thanks to Stuart Reges for originally showing me the problem.<h3>Stanford CS Education Library Doc #109</h3>This is article #109 in the Stanford CS Education Library -- <a href="http://cslibrary.stanford.edu/109/">http://cslibrary.stanford.edu/109/</a>.This and other free educational materials are available at <a href="http://cslibrary.stanford.edu/">http://cslibrary.stanford.edu/</a>.Permission is given for this article to be used, reproduced, or sold solong this paragraph and the copyright are clearly reproduced. Related articlesin the library include <a href="http://cslibrary.stanford.edu/103/">LinkedList Basics (#103)</a>, <a href="http://cslibrary.stanford.edu/105/">LinkedList Problems (#105)</a>, and&nbsp; <a href="http://cslibrary.stanford.edu/110/">BinaryTrees (#110)</a>.<br>&nbsp;<h3>Contents</h3><ol><li><a href="#tree">Ordered binary tree</a></li><li><a href="#list">Circular doubly linked list</a></li><li><a href="#challenge">The Challenge</a></li><li><a href="#problem">Problem Statement</a></li><li><a href="#lessons">Lessons and Solution Code</a></li></ol><p><br><hr WIDTH="100%"><h2>Introduction</h2>The problem will use two data structures -- an ordered binary tree anda circular doubly linked list. Both data structures store sorted elements,but they look very different.<h2><a NAME="tree"></a>1. Ordered Binary Tree</h2>In the ordered binary tree, each node contains a single data element and"small" and "large" pointers to sub-trees (sometimes the two pointers arejust called "left" and "right"). Here's an ordered binary tree of the numbers1 through 5...<center><p><img SRC="tree.gif" ALT="ordered binary tree" VSPACE=10 height=306 width=440><br>Figure-1 -- ordered binary tree</center><p>All the nodes in the "small" sub-tree are less than or equal to thedata in the parent node. All the nodes in the "large" sub-tree are greaterthan the parent node. So in the example above, all the nodes in the "small"sub-tree off the 4 node are less than or equal to 4, and all the nodesin "large" sub-tree are greater than 4. That pattern applies for each nodein the tree. A null pointer effectively marks the end of a branch in thetree. Formally, a null pointer represents a tree with zero elements. Thepointer to the topmost node in a tree is called the "root".<h2><a NAME="list"></a>2. Circular Doubly Linked List</h2>Here's a circular doubly linked list of the numbers 1 through 5...<center><img SRC="list.gif" ALT="circular doubly linked list" VSPACE=10 height=261 width=448><br>Figure-2 -- doubly linked circular list</center><p>The circular doubly linked list is a standard linked list with two additionalfeatures...<ul><li>"Doubly linked" means that each node has two pointers -- the usual "next"pointer that points to the next node in the list and a "previous" pointerto the previous node.</li><li>"Circular" means that the list does not terminate at the first and lastnodes. Instead, the "next" from the last node wraps around to the firstnode. Likewise, the "previous" from the first node wraps around to thelast node.</li></ul>We'll use the convention that a null pointer represents a list with zeroelements. It turns out that a length-1 list looks a little silly...<center><img SRC="single.gif" ALT="list length one" VSPACE=10 height=108 width=139><br>Figure-3 -- a length-1 circular doubly linked list</center><p>The single node in a length-1 list is both the first and last node,so its pointers point to itself. Fortunately, the length-1 case obeys therules above so no special case is required.<h2>The Trick -- Separated at Birth?</h2>Here's the trick that underlies the Great Tree-List Problem: look at thenodes that make up the ordered binary tree. Now look at the nodes thatmake up the linked list. The nodes have the same type structure -- theyeach contain an element and two pointers. The only difference is that inthe tree, the two pointers are labeled "small" and "large" while in thelist they are labeled "previous" and "next". Ignoring the labeling, thetwo node types are the same.<p><hr WIDTH="100%"><h2><a NAME="challenge"></a>3. The Challenge</h2>The challenge is to take an ordered binary tree and rearrange the internalpointers to make a circular doubly linked list out of it. The "small" pointershould play the role of "previous" and the "large" pointer should playthe role of "next". The list should be arranged so that the nodes are inincreasing order...<center><p><img SRC="treelist1.gif" ALT="tree changed to list 1" VSPACE=10 height=405 width=363><br>Figure-4 --&nbsp; original tree with list "next" arrows added</center><p>This drawing shows the original tree drawn with plain black lines withthe "next" pointers for the desired list structure drawn as arrows. The"previous" pointers are not shown.<br>&nbsp;<h2>Complete Drawing</h2><center><p><br><img SRC="treelist2.gif" ALT="tree changed to list 2" height=409 width=368><br>Figure-5 -- original tree with "next" and "previous" list arrows added</center>This drawing shows the all of the problem state -- the original tree isdrawn with plain black lines and the desired next/previous pointers areadded in as arrows. Notice that starting with the head pointer, the structureof next/previous pointers defines a list of the numbers 1 through 5 withexactly the same structure as the list in figure-2. Although the nodesappear to have different spatial arrangement between the two drawings,that's just an artifact of the drawing. The structure defined by the thepointers is what matters.<h2><a NAME="problem"></a>4. Problem Statement</h2>Here's the formal problem statement: Write a recursive function <tt>treeToList(Noderoot) </tt>that takes an ordered binary tree and rearranges the internalpointers to make a circular doubly linked list out of the tree nodes. The"previous" pointers should be stored in the "small" field and the "next"pointers should be stored in the "large" field. The list should be arrangedso that the nodes are in increasing order. Return the head pointer to thenew list. The operation can be done in O(n) time -- essentially operatingon each node once. Basically take figure-1 as input and rearrange the pointersto make figure-2.<p>Try the problem directly, or see the hints below.<p><hr WIDTH="100%"><h2>Hints</h2><h3>Hint #1</h3>The recursion is key. Trust that the recursive call on each sub-tree worksand concentrate on assembling the outputs of the recursive calls to buildthe result. It's too complex to delve into how each recursive call is goingto work -- trust that it did work and assemble the answer from there.<h3>Hint #2</h3>The recursion will go down the tree, recursively changing the small andlarge sub-trees into lists, and then append those lists together with theparent node to make larger lists. Separate out a utility function <tt>append(Nodea, Node b)</tt> that takes two circular doubly linked lists and appendsthem together to make one list which is returned. Writing a separate utilityfunction helps move some of the complexity out of the recursive function.<p><hr WIDTH="100%"><h2><a NAME="lessons"></a>5. Lessons and Solution Code</h2>The solution code is given below in <a href="#java">Java</a> and <a href="#c">C</a>.The most important method is treeToList() and the helper methods join()and append(). Here are the lessons I see in the two solutions...<ul><li>Trust that the recursive calls return correct output when fed correct input-- make the leap of faith. Look at the partial results that the recursivecalls give you, and construct the full result from them. If you try tostep into the recursive calls to think how they are working, you'll gocrazy.</li><li>Decomposing out well defined helper functions is a good idea. Writing thelist-append code separately helps you concentrate on the recursion whichis complex enough on its own.</li></ul><h2><a NAME="java"></a>Java Solution Code</h2><pre>// TreeList.java/*&nbsp;Demonstrates the greatest recursive pointer problem ever --&nbsp;recursively changing an ordered binary tree into a circular&nbsp;doubly linked list.&nbsp;See http://cslibrary.stanford.edu/109/&nbsp;&nbsp;This code is not especially OOP.&nbsp;This code is free for any purpose.&nbsp;Feb 22, 2000&nbsp;Nick Parlante nick.parlante@cs.stanford.edu*//*&nbsp;This is the simple Node class from which the tree and list&nbsp;are built. This does not have any methods -- it's just used&nbsp;as dumb storage by TreeList.&nbsp;The code below tries to be clear where it treats a Node pointer&nbsp;as a tree vs. where it is treated as a list.*/class Node {&nbsp;&nbsp;&nbsp; int data;&nbsp;&nbsp;&nbsp; Node small;&nbsp;&nbsp;&nbsp; Node large;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Node(int data) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.data = data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small = null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; large = null;&nbsp;&nbsp;&nbsp; }}/*&nbsp;TreeList main methods:&nbsp;-join() -- utility to connect two list nodes&nbsp;-append() -- utility to append two lists&nbsp;-treeToList() -- the core recursive function&nbsp;-treeInsert() -- used to build the tree*/class TreeList {&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp; helper function -- given two list nodes, join them&nbsp;&nbsp;&nbsp;&nbsp; together so the second immediately follow the first.&nbsp;&nbsp;&nbsp;&nbsp; Sets the .next of the first and the .previous of the second.&nbsp;&nbsp;&nbsp; */&nbsp;&nbsp;&nbsp; public static void join(Node a, Node b) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.large = b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.small = a;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp; helper function -- given two circular doubly linked&nbsp;&nbsp;&nbsp;&nbsp; lists, append them and return the new list.&nbsp;&nbsp;&nbsp; */&nbsp;&nbsp;&nbsp; public static Node append(Node a, Node b) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if either is null, return the other&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a==null) return(b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (b==null) return(a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // find the last node in each using the .previous pointer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node aLast = a.small;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node bLast = b.small;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // join the two together to make it connected and circular&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; join(aLast, b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; join(bLast, a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(a);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp; --Recursion--&nbsp;&nbsp;&nbsp;&nbsp; Given an ordered binary tree, recursively change it into&nbsp;&nbsp;&nbsp;&nbsp; a circular doubly linked list which is returned.&nbsp;&nbsp;&nbsp; */&nbsp;&nbsp;&nbsp; public static Node treeToList(Node root) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // base case: empty tree -> empty list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (root==null) return(null);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Recursively do the subtrees (leap of faith!)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node aList = treeToList(root.small);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node bList = treeToList(root.large);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Make the single root node into a list length-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in preparation for the appending&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root.small = root;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root.large = root;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // At this point we have three lists, and it's&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // just a matter of appending them together&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in the right order (aList, root, bList)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aList = append(aList, root);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aList = append(aList, bList);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(aList);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;&nbsp;&nbsp; Given a non-empty tree, insert a new node in the proper&nbsp;&nbsp;&nbsp;&nbsp; place. The tree must be non-empty because Java's lack&nbsp;&nbsp;&nbsp;&nbsp; of reference variables makes that case and this&nbsp;&nbsp;&nbsp;&nbsp; method messier than they should be.&nbsp;&nbsp;&nbsp; */&nbsp;&nbsp;&nbsp; public static void treeInsert(Node root, int newData) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (newData&lt;=root.data) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (root.small!=null) treeInsert(root.small, newData);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else root.small = new Node(newData);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (root.large!=null) treeInsert(root.large, newData);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else root.large = new Node(newData);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do an inorder traversal to print a tree&nbsp;&nbsp;&nbsp; // Does not print the ending "\n"&nbsp;&nbsp;&nbsp; public static void printTree(Node root) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (root==null) return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printTree(root.small);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(Integer.toString(root.data) + " ");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printTree(root.large);&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do a traversal of the list and print it out&nbsp;&nbsp;&nbsp; public static void printList(Node head) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node current = head;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (current != null) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(Integer.toString(current.data) + " ");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current = current.large;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (current == head) break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println();&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Demonstrate tree->list with the list 1..5&nbsp;&nbsp;&nbsp; public static void main(String[] args) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // first build the tree shown in the problem document&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // http://cslibrary.stanford.edu/109/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node root = new Node(4);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; treeInsert(root, 2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; treeInsert(root, 1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; treeInsert(root, 3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; treeInsert(root, 5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("tree:");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printTree(root);&nbsp;&nbsp; // 1 2 3 4 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("list:");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node head = treeToList(root);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printList(head);&nbsp;&nbsp; // 1 2 3 4 5&nbsp;&nbsp; yay!&nbsp;&nbsp;&nbsp; }}</pre><h2><a NAME="c"></a>C Solution Code</h2><pre>/*&nbsp;TreeList.c&nbsp;&nbsp;C code version of the great Tree-List recursion problem.&nbsp;See http://cslibrary.stanford.edu/109/ for the full&nbsp;discussion and the Java solution.&nbsp;&nbsp;This code is free for any purpose.&nbsp;Feb 22, 2000&nbsp;Nick Parlante nick.parlante@cs.stanford.edu*/#include &lt;stdio.h>#include &lt;stddef.h>#include &lt;stdlib.h>/* The node type from which both the tree and list are built */struct node {&nbsp;&nbsp;&nbsp; int data;&nbsp;&nbsp;&nbsp; struct node* small;&nbsp;&nbsp;&nbsp; struct node* large;};typedef struct node* Node;/*&nbsp;helper function -- given two list nodes, join them&nbsp;together so the second immediately follow the first.&nbsp;Sets the .next of the first and the .previous of the second.*/static void join(Node a, Node b) {&nbsp;&nbsp;&nbsp; a->large = b;&nbsp;&nbsp;&nbsp; b->small = a;}/*&nbsp;helper function -- given two circular doubly linked&nbsp;lists, append them and return the new list.*/static Node append(Node a, Node b) {&nbsp;&nbsp;&nbsp; Node aLast, bLast;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a==NULL) return(b);&nbsp;&nbsp;&nbsp; if (b==NULL) return(a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aLast = a->small;&nbsp;&nbsp;&nbsp; bLast = b->small;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; join(aLast, b);&nbsp;&nbsp;&nbsp; join(bLast, a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(a);}/*&nbsp;--Recursion--&nbsp;Given an ordered binary tree, recursively change it into&nbsp;a circular doubly linked list which is returned.*/static Node treeToList(Node root) {&nbsp;&nbsp;&nbsp; Node aList, bList;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (root==NULL) return(NULL);&nbsp;&nbsp;&nbsp; /* recursively solve subtrees -- leap of faith! */&nbsp;&nbsp;&nbsp; aList = treeToList(root->small);&nbsp;&nbsp;&nbsp; bList = treeToList(root->large);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Make a length-1 list ouf of the root */&nbsp;&nbsp;&nbsp; root->small = root;&nbsp;&nbsp;&nbsp; root->large = root;&nbsp;&nbsp;&nbsp; /* Append everything together in sorted order */&nbsp;&nbsp;&nbsp; aList = append(aList, root);&nbsp;&nbsp;&nbsp; aList = append(aList, bList);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(aList);/* Create a new node */static Node newNode(int data) {&nbsp;&nbsp;&nbsp; Node node = (Node) malloc(sizeof(struct node));&nbsp;&nbsp;&nbsp; node->data = data;&nbsp;&nbsp;&nbsp; node->small = NULL;&nbsp;&nbsp;&nbsp; node->large = NULL;&nbsp;&nbsp;&nbsp; return(node);}/* Add a new node into a tree */static void treeInsert(Node* rootRef, int data) {&nbsp;&nbsp;&nbsp; Node root = *rootRef;&nbsp;&nbsp;&nbsp; if (root == NULL) *rootRef = newNode(data);&nbsp;&nbsp;&nbsp; else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (data &lt;= root->data) treeInsert(&amp;(root->small), data);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else treeInsert(&amp;(root->large), data);&nbsp;&nbsp;&nbsp; }}static void printList(Node head) {&nbsp;&nbsp;&nbsp; Node current = head;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(current != NULL) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%d ", current->data);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current = current->large;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (current == head) break;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; printf("\n");}/* Demo that the code works */int main() {&nbsp;&nbsp;&nbsp; Node root = NULL;&nbsp;&nbsp;&nbsp; Node head;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; treeInsert(&amp;root, 4);&nbsp;&nbsp;&nbsp; treeInsert(&amp;root, 2);&nbsp;&nbsp;&nbsp; treeInsert(&amp;root, 1);&nbsp;&nbsp;&nbsp; treeInsert(&amp;root, 3);&nbsp;&nbsp;&nbsp; treeInsert(&amp;root, 5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = treeToList(root);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printList(head);&nbsp;&nbsp;&nbsp; /* prints: 1 2 3 4 5&nbsp; */&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(0);}</pre>&nbsp;<p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</body></html>
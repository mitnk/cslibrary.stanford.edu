<!doctype html public "-//w3c//dtd html 4.0 transitional//en"><html><head><title>Pointer Basics</title><meta  name= "description" content= "Stanford CS Education Library: a 6 page introduction the basics of pointers as they work in several languages -- C, Java, C++, and Pascal. This is the companion text for the<a href=http://cslibrary.stanford.edu/104/>Pointer Fun</a> video short."><meta  name= "keywords"content= "pointer, pointee, pointer fun, basic pointer, pointer introduction, video, animation, animated"></head><body bgcolor=white><h1>Pointer Basics</h1><p>This document introduces the basics of pointers as they work in several computer languages -- C, C++, Java, and Pascal. This document is the companion document for the<a href="http://cslibrary.stanford.edu/104/">Pointer Fun with Binky</a> digital video, or it may be used by itself.<ul><li> <a href=#s1>Section 1</a> -- The three basic rules of pointers<li> <a href=#s2>Section 2</a> -- A simple code example (the same example used in the video)<li> <a href=#s3>Section 3</a> -- Study questions with solutions</ul><p>This is document 106 in the Stanford CS Education Library. This and other free materials are available at <a href=http://cslibrary.stanford.edu/>cslibrary.stanford.edu</a>. Some documents that are related to this one include...<ul><li> Pointer Fun Video -- a silly 3 minute digital video on the basics of pointers. Designed to go with the document in front of you.(<a href=http://cslibrary.stanford.edu/104/>http://cslibrary.stanford.edu/104/</a>)<li> Pointers and Memory --a 31 page explanation of the common features and techniques for using pointers and memory in C and other languages.(<a href=http://cslibrary.stanford.edu/102/>http://cslibrary.stanford.edu/102/</a>)</ul><a name=s1><h2>Section 1 -- Pointer Rules</h2>One of the nice things about pointers is that the rules which govern how they work are pretty simple. The rules can be layered together to get complex results, but the individual rules remain simple.<h3>1) Pointers and Pointees</h3><p>A <b>pointer</b> stores a reference to something. Unfortunately there is no fixed term for the thing that the pointer points to, and across different computer languages there is a wide variety of things that pointers point to. We use the term  <b>pointee</b> for the thing that the pointer points to, and we stick to the basic properties of the pointer/pointee relationship which are true in all languages. The term "reference" means pretty much the same thing as "pointer" -- "reference" implies a more high-level discussion, while  "pointer" implies the traditional compiled language implementation of pointers as addresses. For the basic pointer/pointee rules covered here, the terms are effectively equivalent.<p><img src=PointerPointee.gif alt="Pointer pointing to pointee"><br>The above drawing shows a pointer named <code>x</code> pointing to a pointee which is storing the value 42. A pointer is usually drawn as a box, and the reference it stores is drawn as an arrow starting in the box and leading to its pointee.<p>Allocating a pointer and allocating a pointee for it to point to are two separate steps. You can think of the pointer/pointee structure as operating at two levels. Both the levels must be set up for things to work. The most common error is concentrating on writing code which manipulates the pointer level, but forgetting to set up the pointee level. Sometimes pointer operations that do not touch the pointees are called "shallow" while operations on the pointees are called "deep".<h3>2) Dereferencing</h3>The <b>dereference</b> operation starts at the pointer and follows its arrow over to access its pointee. The goal may be to look at the pointee state or to change the pointee state.<p>The dereference operation on a pointer only works if the pointer has a pointee -- the pointee must be allocated and the pointer must be set to point to it. The most common error in pointer code is forgetting to set up the pointee. The most common runtime crash because of that error in the code is a failed dereference operation. In Java the incorrect dereference will be flagged politely by the runtime system. In compiled languages such as C, C++, and Pascal, the incorrect dereference will sometimes crash, and other times corrupt memory in some subtle, random way. Pointer bugs in compiled languages can be difficult to track down for this reason.<h3>3) Pointer Assignment</h3><p><b>Pointer assignment</b> between two pointers makes them point to the same pointee. So the assignment <code>y = x;</code> makes <code>y</code> point to the same pointee as <code>x</code>. Pointer assignment does not touch the pointees. It just changes one pointer to have the same reference as another pointer. After pointer assignment, the two pointers are said to be "sharing" the pointee.<a name=s2><h2>Section 2 -- Binky's Code Example</h2>This section presents the same code example used in the <a href=http://cslibrary.stanford.edu/104/>Pointer Fun With Binky</a> video. There are versions of the code in several computer languages. All the versions have the same structure and demonstrate the same basic rules and lessons about pointers; they just vary in their syntax. Independent of any particular language, the basic structure of the example is...<table width="100%" border><tr><td>1. Allocate two pointers <code>x</code> and <code>y</code>. Allocating the pointers <b>does not</b> allocate any pointees.</td><td><img src=1.gif></td></tr><tr><td>2. Allocate a pointee and set <code>x</code> to point to it. Each language has its own syntax for this. What matters is that memory is dynamically allocated for one pointee, and <code>x</code> is set to point to that pointee. </td><td><img src=2.gif></td></tr><tr><td>3. Dereference <code>x</code> to store 42 in its pointee. This is a basic example of the dereference operation. Start at <code>x</code>, follow the arrow over to access its pointee. </td><td><img src=3.gif></td></tr><tr><td>4. Try to dereference <code>y</code> to store 13 in its pointee. This crashes because <code>y</code> does not have a pointee -- it was never assigned one.</td><td><img src=4.gif></td></tr><tr><td>5. Assign <code>y = x;</code> so that <code>y</code> points to <code>x</code>'s pointee. Now <code>x</code> and <code>y</code> point to the same pointee -- they are "sharing".</td><td><img src=5.gif></td></tr><tr><td>6. Try to dereference <code>y</code> to store 13 in its pointee. This time it works, because the previous assignment gave <code>y</code> a pointee. </td><td><img src=6.gif></td></tr></table><h3>Versions</h3><p>Below are versions of this example in <a href=#c>C</a>, <a href=#java>Java</a>, <a href=#cpp>C++</a>, and <a href=#pascal>Pascal</a>. They all do the same thing -- the syntax is just adjusted for each language.<a name=c><h3>C Version</h3><p>The pointers <code>x</code> and <code>y</code> are allocated as local variables. The type <code>int*</code> means "pointer which points to ints". As Binky learns, the pointers do not automatically get pointees. The pointee for <code>x</code> is dynamically allocated separately with the standard library function <code>malloc()</code>. The syntax <code>*x</code> dereferences x to access its pointee.<pre>void main() {       int*    x;  // Allocate the pointers x and y    int*    y;  // (but not the pointees)        x = malloc(sizeof(int));    // Allocate an int pointee,                                // and set x to point to it        *x = 42;    // Dereference x to store 42 in its pointee        *y = 13;    // CRASH -- y does not have a pointee yet        y = x;      // Pointer assignment sets y to point to x's pointee        *y = 13;    // Dereference y to store 13 in its (shared) pointee}</pre><p>Another way to play with pointers in C (or C++) is using the ampersand (<code>&</code>) operator to compute a pointer to local memory in the stack. However, pointees dynamically allocated in the heap are the most common, so that's what we show.<a name=java><h3>Java Version</h3>In Java, the most common pointer/pointee structure is a local variable pointer which points to a pointee object of some class. So in keeping with our plan to create a pointee which stores an integer, we define an <code>IntObj</code> class that stores one integer. We can then create an <code>IntObj</code> pointee to store the int. As Binky learns, allocating the pointer with code like <code>IntObj x;</code> does not automatically allocate the pointee. The <code>IntObj</code> pointee is allocated with a call to <code>new</code>. The syntax <code>x.value</code> dereferences <code>x</code> to access the <code>.value</code> field in its pointee.<pre>class IntObj {    public int value;}public class Binky() {    public static void main(String[] args) {        IntObj  x;  // Allocate the pointers x and y        IntObj  y;  // (but not the IntObj pointees)                x = new IntObj();   // Allocate an IntObj pointee                            // and set x to point to it                x.value = 42;   // Dereference x to store 42 in its pointee                y.value = 13;   // CRASH -- y does not have a pointee yet                y = x;  // Pointer assignment sets y to point to x's pointee                y.value = 13;   // Deference y to store 13 in its (shared) pointee    }}   </pre>  <a name=cpp><h3>C++ Version</h3>The only difference in this version from the C version above is that the standard operator <code>new</code> is used instead of <code>malloc()</code>.<pre>void main() {       int*    x;  // Allocate the pointers x and y    int*    y;  // (but not the pointees)        x = new int;    // Allocate an int pointee,                    // and set x to point to it        *x = 42;    // Dereference x to store 42 in its pointee        *y = 13;    // CRASH -- y does not have a pointee yet        y = x;      // Pointer assignment sets y to point to x's pointee        *y = 13;    // Dereference y to store 13 in its (shared) pointee}</pre><a name=pascal><h3>Pascal Version</h3>This is structurally identical to the C version, but with Pascal syntax. The type <code>^Integer</code> means "pointer which points to integers". As Binky learns, allocating the pointer does not automatically allocate its pointee. The standard procedure <code>New()</code> takes a pointer argument, allocates a new pointee, and sets the pointer to point to it. The expression <code>x^</code> dereferences x to access its pointee.<pre>Procedure main    var x:^Integer; /* Allocate the pointers x and y */    var y:^Integer; /* (but not the pointees)        */Begin    New(x); /* Allocate a pointee and set x to point to it */        x^ := 42;   /* Deference x to store 42 in its pointee */        y^ := 13;   /* CRASH -- y does not have a pointee yet */        y := x; 	/* Pointer assignment makes y point to x's pointee */        y^ := 13;   /* Dereference y to store 13 in its (shared) pointee */End;</pre><a name=s3><h2>Section 3 -- Study Questions</h2><p>These study questions cover review basic features of pointers. Two of the questions make heavy use of memory drawings. Memory drawings are an excellent way to think through pointer problems.<h3>Question 1</h3><p>At the end of the above code, <code>y</code> is set to have a pointee and then dereferenced it store the number 13 into its pointee. After this happens, what is the value of <code>x</code>'s pointee?<p><b>Answer:</b> The value of <code>x</code>'s pointee is 13 because it is also <code>y</code>'s pointee. This is what sharing is all about -- multiple pointers pointing to one pointee.<h3>Question 2</h3><p>Consider the following drawing...<p><img src=TwoPointers.gif><p>Using the language of your choice, write some code that creates the above pointer structure.<p><b>Answer:</b> The basic steps are...<ol><li> Allocate two pointers.<li> Allocate two pointees and set the pointers to point to them.<li> Store the numbers 1 and 2 into the pointees.<li> Assign the first pointer to point to the second pointee. This "loses" the reference to the first pointee which is unusual, but that's what the question calls for.</ol><table width="100%" border><tr><th>C Code</th><th>Java Code<th></tr><tr><td><pre>{	int* x;	int* y;	x = malloc(sizeof(int));	y = malloc(sizeof(int));	*x = 1;	*y = 2;	x = y;}</pre></td><td><pre>{	IntObj x;	IntObj y;	x = new IntObj();	y = new IntObj();	x.value = 1;	y.value = 2;	x = y;}</pre></td></tr></table><h3>Question 3</h3><p>Suppose you have a pointee type called "Node" which contains two things: an int, and a pointer to another Node (the declaration for such a Node type is given below). With such a pointee type, you could arrange three Node pointees in a structure where they were pointing to each other like this...<p><img src=ThreeNodes.gif><p>The pointer named <code>x</code> points to the first Node pointee. The first Node contains a pointer to the second, the second contains a pointer to the third, and the third contains a pointer back to the first. This structure can be build using only the rules of pointee allocation, dereferencing, and assignment that we have seen. Using the declaration below, each Node contains an integer named <code>value</code> and a pointer to another Node named <code>next</code>.<table width="100%" border><tr><th>C Code</th><th>Java Code<th></tr><tr><td><pre>struct Node {	int value;	struct Node* next;};</pre></td><td><pre>class Node {	public int value;	public Node next;};</pre></td></tr></table><p>Write the code to build the structure in the above drawing. For convenience, you may use temporary pointers in addition to <code>x</code>. The only new syntax required is that in C, the operator <code>-&gt;</code> dereferences a pointer to access a field in the pointee -- so <code>-&gt;value</code> accesses the field named <code>value</code> in <code>x</code>'s pointee. <p><b>Answer</b>The basic steps are...<ol><li> Allocate three pointers: x for the first Node, and temporary pointers <code>y</code> and <code>z</code> for the other two Nodes.<li> Allocate three Node pointees and store references to them in the three pointers.<li> Dereference each pointer to store the appropriate number into the <code>value</code> field in its pointee.<li> Dereference each pointer to access the <code>.next</code> field in its pointee, and use pointer assignment to set the <code>.next</code> field to point to the appropriate Node.</ol><table width="100%" border><tr><th>C Code</th><th>Java Code<th></tr><tr><td><pre>{	// Allocate the pointers	struct Node* x;	struct Node* y;	struct Node* z;	// Allocate the pointees	x = malloc(sizeof(Node));	y = malloc(sizeof(Node));	z = malloc(sizeof(Node));	// Put the numbers in the pointees	x->value = 1;	y->value = 2;	z->value = 3;	// Put the pointers in the pointees	x->next = y;	y->next = z;	z->next = x;}</pre></td><td><pre>{	// Allocate the pointers	Node x;	Node y;	Node z;	// Allocate the pointees	x = new Node();	y = new Node();	z = new Node();	// Put the numbers in the pointees	x.value = 1;	y.value = 2;	z.value = 3;	// Put the pointers in the pointees	x.next = y;	y.next = z;	z.next = x;}</pre></td></tr></table><p>The Node structure introduced here is actually a real data type used to build the "linked list" data structure. Linked lists are a realistic applied use of pointers and are an excellent area to develop your pointer skills. See <a href=http://cslibrary.stanford.edu/103/>Linked List Basics</a> and  <a href=http://cslibrary.stanford.edu/105/>Linked List Problems</a> in the Stanford CS Education Library for lots of linked list material.<h3>Postscript</h3><p>Copyright Nick Parlante, 1999. This material may be copied and redistributed so long as the standard Stanford CS Education Library notice on the first page is retained: "This is document 106 in the Stanford CS Education Library. This and other free materials are available at <a href=http://cslibrary.stanford.edu/>cslibrary.stanford.edu</a>."<p>I hope that you benefit from this material in the spirit of goodwill in which it is given. That someone seeking education should have the opportunity to find it.<hr><p>Up to  the <a href="http://cslibrary.stanford.edu/">CS Education Library Home</a></body></html>